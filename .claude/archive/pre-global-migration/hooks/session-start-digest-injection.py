#!/usr/bin/env python3
"""
SessionStart hook - Injects previous session digest
Uses the digest files generated by DevMaestro memory service (external-ready)

VERSION: 2.1.1
LAST MODIFIED: 2025-10-11
CHANGELOG:
  v2.1.1 (2025-10-11):
    - Changed to AUTO-INSTALL updates (not just notify)
    - Downloads and installs updates automatically
    - Shows message: "DevMaestro updated, restart Claude for changes"
    - Non-blocking with 30-second timeout for install
    - Zero user intervention required
  v2.1.0 (2025-10-11):
    - Added automatic update check on session start
    - Silently checks server for DevMaestro updates
    - Notifies user of available updates (granular file-level)
    - Non-blocking with 8-second timeout
    - Ensures users stay on latest version during beta
  v2.0.0 (2025-10-11):
    - Added automatic session ID update at session start
    - Now calls update-session-id.py before loading digest
    - Ensures current session is always tracked correctly
    - Prevents stale session IDs from breaking memory system
  v1.0.0 (Original):
    - Basic digest injection functionality
    - Loads latest.digest.md or most recent timestamped digest
    - Provides session start messages
"""
import sys
import json
import subprocess
from pathlib import Path

def update_session_id():
    """Call helper script to update current session ID"""
    try:
        helper_script = Path(".claude/hooks/update-session-id.py")
        if helper_script.exists():
            result = subprocess.run(
                ["python3", str(helper_script)],
                capture_output=True,
                text=True,
                timeout=10
            )
            # Helper script handles its own output
            return True
        return False
    except:
        return False

def check_for_updates_silent():
    """Silently check for DevMaestro updates and auto-install (non-blocking)"""
    try:
        auto_update_script = Path(".claude/hooks/auto-update.py")
        if not auto_update_script.exists():
            # Try global directory
            auto_update_script = Path.home() / ".claude" / "hooks" / "auto-update.py"
            if not auto_update_script.exists():
                return False
        
        # Check if updates are available
        check_result = subprocess.run(
            ["python3", str(auto_update_script), "--check"],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        # Exit code 1 means updates available
        if check_result.returncode == 1:
            # Auto-install updates
            install_result = subprocess.run(
                ["python3", str(auto_update_script), "--install"],
                capture_output=True,
                text=True,
                timeout=30  # Allow time for download
            )
            
            if install_result.returncode == 0:
                # Success - notify user to restart
                print("\n" + "="*60, file=sys.stderr)
                print("‚úÖ DevMaestro has been updated!", file=sys.stderr)
                print("="*60, file=sys.stderr)
                print("üìù Please restart Claude Code for changes to take effect.", file=sys.stderr)
                print("="*60 + "\n", file=sys.stderr)
            else:
                # Failed - show error but don't block
                print("\n‚ö†Ô∏è  DevMaestro update failed. Run /dm-init to retry.\n", file=sys.stderr)
        
        return True
        
    except subprocess.TimeoutExpired:
        # Timeout - don't block session start
        return False
    except Exception:
        # Any other error - fail silently
        return False

def find_latest_digest():
    """Find the most recent session digest from memory service"""
    backup_dir = Path(".claude/memory_backups")
    
    # Try latest.digest.md (external-ready architecture writes this as regular file)
    latest_file = backup_dir / "latest.digest.md"
    if latest_file.exists() and latest_file.is_file():
        return latest_file
    
    # Fallback: find most recent digest file by timestamp
    digest_files = []
    for digest_path in backup_dir.rglob("*.digest.md"):
        try:
            if not digest_path.is_symlink() and digest_path.is_file():
                if "-" in digest_path.name and "_" in digest_path.name:
                    digest_files.append(digest_path)
        except:
            continue
    
    if not digest_files:
        return None
    
    digest_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return digest_files[0]

def load_digest(digest_file):
    """Load digest content"""
    try:
        return digest_file.read_text()
    except Exception as e:
        return None

def main():
    # First, update session ID for this new session
    update_session_id()
    
    # Check for DevMaestro updates (silent, non-blocking)
    check_for_updates_silent()
    
    digest_file = find_latest_digest()
    
    if not digest_file:
        message = """üîÑ Starting fresh session

No previous session digest found.

DevMaestro memory service will track this session.

‚ö†Ô∏è If you just installed DevMaestro, run /dm-init to verify configuration.
üí° If experiencing issues, run /dm-doctor for diagnostics."""
        output = {"continue": True, "systemMessage": message}
        print(json.dumps(output))
        return 0
    
    digest_content = load_digest(digest_file)
    
    if not digest_content:
        message = """‚ö†Ô∏è Error loading session digest

Found digest file but couldn't read it.

DevMaestro memory service will track this session.

üí° Run /dm-doctor to diagnose memory system issues."""
        output = {"continue": True, "systemMessage": message}
        print(json.dumps(output))
        return 0
    
    # Inject digest as context
    message = f"""üìù Previous Session Context Loaded

{digest_content}

---

üíæ This digest was generated by DevMaestro memory service.
üîÑ Your current session will also be saved when you close it."""
    
    output = {"continue": True, "systemMessage": message}
    print(json.dumps(output))
    return 0

if __name__ == "__main__":
    sys.exit(main())
