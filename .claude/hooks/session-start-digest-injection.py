#!/usr/bin/env python3
"""
SessionStart hook - Injects previous session digest
Uses the digest files generated by DevMaestro memory service (external-ready)

VERSION: 2.1.8
LAST MODIFIED: 2025-10-12
CHANGELOG:
  v2.1.8 (2025-10-12):
    - ALWAYS checks server for updates on every session start
    - Downloads and installs in TRUE BACKGROUND (no blocking)
    - Session continues immediately while update downloads
    - Shows notification: "Update downloaded, restart to apply"
    - Modern IDE behavior (like Cursor, Windsurf, VS Code)
    - User never interrupted, just restart when convenient
  v2.1.1 (2025-10-11):
    - Changed to AUTO-INSTALL updates (not just notify)
    - Downloads and installs updates automatically
    - Shows message: "DevMaestro updated, restart Claude for changes"
    - Non-blocking with 30-second timeout for install
    - Zero user intervention required
  v2.1.0 (2025-10-11):
    - Added automatic update check on session start
    - Silently checks server for DevMaestro updates
    - Notifies user of available updates (granular file-level)
    - Non-blocking with 8-second timeout
    - Ensures users stay on latest version during beta
  v2.0.0 (2025-10-11):
    - Added automatic session ID update at session start
    - Now calls update-session-id.py before loading digest
    - Ensures current session is always tracked correctly
    - Prevents stale session IDs from breaking memory system
  v1.0.0 (Original):
    - Basic digest injection functionality
    - Loads latest.digest.md or most recent timestamped digest
    - Provides session start messages
"""
import sys
import json
import subprocess
from pathlib import Path

def update_session_id():
    """Call helper script to update current session ID"""
    try:
        # Try local directory first
        helper_script = Path(".claude/hooks/update-session-id.py")
        if not helper_script.exists():
            # Fallback to global directory
            helper_script = Path.home() / ".claude" / "hooks" / "update-session-id.py"
        
        if helper_script.exists():
            result = subprocess.run(
                ["python3", str(helper_script)],
                capture_output=True,
                text=True,
                timeout=10
            )
            # Helper script handles its own output
            return True
        return False
    except:
        return False

def check_for_updates_silent():
    """
    ALWAYS check server for updates and download in TRUE BACKGROUND.
    Modern IDE behavior: check every session, download silently, notify to restart.
    Non-blocking - session continues immediately while update downloads.
    """
    try:
        auto_update_script = Path(".claude/hooks/auto-update.py")
        if not auto_update_script.exists():
            # Try global directory
            auto_update_script = Path.home() / ".claude" / "hooks" / "auto-update.py"
            if not auto_update_script.exists():
                return False
        
        # ALWAYS check for updates (quick check, ~1 second)
        check_result = subprocess.run(
            ["python3", str(auto_update_script), "--check"],
            capture_output=True,
            text=True,
            timeout=3  # Quick check only
        )
        
        # Exit code 1 means updates available
        if check_result.returncode == 1:
            # Show notification immediately
            print("\n" + "="*60, file=sys.stderr)
            print("üîÑ DevMaestro update downloading in background...", file=sys.stderr)
            print("="*60 + "\n", file=sys.stderr)
            
            # Start download/install in TRUE BACKGROUND (Popen, don't wait)
            subprocess.Popen(
                ["python3", str(auto_update_script), "--install"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True  # Detach from parent process
            )
            
            # Show restart reminder
            print("üí° Update will be ready after you restart Claude.\n", file=sys.stderr)
        
        # Return immediately, don't wait for download
        return True
        
    except subprocess.TimeoutExpired:
        # Check timed out - fail silently, don't block session
        return False
    except Exception:
        # Any other error - fail silently
        return False

def find_latest_digest():
    """Find the most recent session digest from memory service"""
    backup_dir = Path(".claude/memory_backups")
    
    # Try latest.digest.md (external-ready architecture writes this as regular file)
    latest_file = backup_dir / "latest.digest.md"
    if latest_file.exists() and latest_file.is_file():
        return latest_file
    
    # Fallback: find most recent digest file by timestamp
    digest_files = []
    for digest_path in backup_dir.rglob("*.digest.md"):
        try:
            if not digest_path.is_symlink() and digest_path.is_file():
                if "-" in digest_path.name and "_" in digest_path.name:
                    digest_files.append(digest_path)
        except:
            continue
    
    if not digest_files:
        return None
    
    digest_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return digest_files[0]

def load_digest(digest_file):
    """Load digest content"""
    try:
        return digest_file.read_text()
    except Exception as e:
        return None

def main():
    # First, update session ID for this new session
    update_session_id()
    
    # Check for DevMaestro updates (silent, non-blocking)
    check_for_updates_silent()
    
    digest_file = find_latest_digest()
    
    if not digest_file:
        message = """üîÑ Starting fresh session

No previous session digest found.

DevMaestro memory service will track this session.

‚ö†Ô∏è If you just installed DevMaestro, run /dm-init to verify configuration.
üí° If experiencing issues, run /dm-doctor for diagnostics."""
        output = {"continue": True, "systemMessage": message}
        print(json.dumps(output))
        return 0
    
    digest_content = load_digest(digest_file)
    
    if not digest_content:
        message = """‚ö†Ô∏è Error loading session digest

Found digest file but couldn't read it.

DevMaestro memory service will track this session.

üí° Run /dm-doctor to diagnose memory system issues."""
        output = {"continue": True, "systemMessage": message}
        print(json.dumps(output))
        return 0
    
    # Inject digest as context silently (for AI only)
    # The digest content is available to AI but not displayed to user
    output = {
        "continue": True,
        "context": digest_content  # This provides context to AI without showing user
    }
    print(json.dumps(output))
    return 0

if __name__ == "__main__":
    sys.exit(main())
